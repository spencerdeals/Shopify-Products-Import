// Replace these functions in your frontend/index.html <script> section:

// Fixed createDraftOrder function
async function createDraftOrder() {
    if (!finalCalculation) return;
    
    const btn = document.getElementById('createOrderBtn');
    btn.disabled = true;
    btn.textContent = 'Creating your order...';
    
    try {
        // Get customer information directly in the frontend
        const customerName = prompt('Please enter your full name:');
        const customerEmail = prompt('Please enter your email address:');
        
        if (!customerName || !customerEmail) {
            throw new Error('Customer information is required');
        }
        
        // Validate email format
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(customerEmail)) {
            throw new Error('Please enter a valid email address');
        }
        
        btn.textContent = 'Processing order...';
        
        // Create the order directly with Shopify
        const orderPayload = {
            products: finalCalculation.products,
            deliveryFees: finalCalculation.deliveryFees,
            totals: finalCalculation.totals,
            customer: {
                name: customerName,
                email: customerEmail,
                firstName: customerName.split(' ')[0],
                lastName: customerName.split(' ').slice(1).join(' ')
            },
            originalUrls: finalCalculation.originalUrls
        };
        
        console.log('Creating draft order with payload:', orderPayload);
        
        const response = await fetch('/apps/instant-import/create-draft-order', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(orderPayload)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `HTTP ${response.status}: Failed to create order`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            btn.textContent = 'Order created successfully!';
            
            // Show success message
            alert(`✅ Order Created Successfully!\n\nOrder Number: ${result.draftOrderNumber}\nTotal: $${(result.totalAmount || 0).toFixed(2)}\n\nWhat happens next:\n• We'll review your order within 24 hours\n• If any adjustments are needed, we'll contact you\n• Once confirmed, we'll place the orders with US retailers\n• Estimated delivery: 3-5 weeks\n\nQuestions? Contact us at info@spencerdeals.bm`);
            
            // Reset the form
            setTimeout(() => {
                if (confirm('Would you like to start a new import calculation?')) {
                    location.reload();
                }
            }, 2000);
            
        } else {
            throw new Error(result.error || 'Failed to create order');
        }
        
    } catch (error) {
        console.error('Error creating order:', error);
        
        btn.textContent = 'Confirm & Create Order';
        btn.disabled = false;
        
        // Show detailed error message
        alert(`❌ Error creating order:\n\n${error.message}\n\nPlease try again or contact support at info@spencerdeals.bm`);
    }
}

// Fixed calculateTotals function with proper quantity support
function calculateTotals(deliveryFees) {
    let totalItemCost = 0;
    let totalShippingCost = 0;
    let totalDeliveryFees = 0;
    const activeProducts = [];
    
    // Process all products with quantities
    scrapedProducts.forEach((product, index) => {
        if (product.deleted) return;
        
        // Get the price and quantity from inputs
        const vendor = product.retailer || 'Unknown';
        const vendorProducts = vendorGroups[vendor] || [];
        const productIndex = vendorProducts.indexOf(product);
        const productId = `${vendor.replace(/\s+/g, '')}-${productIndex}`;
        const priceInput = document.getElementById(`price-${productId}`);
        const quantity = productQuantities[productId] || 1;
        
        if (priceInput) {
            product.price = parseFloat(priceInput.value) || 0;
            product.quantity = quantity;
        }
        
        if (product.price > 0) {
            const itemTotal = product.price * quantity;
            const shippingTotal = (product.shippingCost || 0) * quantity;
            
            totalItemCost += itemTotal;
            totalShippingCost += shippingTotal;
            activeProducts.push(product);
        }
    });
    
    // Sum delivery fees
    Object.values(deliveryFees || {}).forEach(fee => {
        totalDeliveryFees += fee || 0;
    });
    
    // Calculate duty (26.5% on product cost only)
    const dutyAmount = totalItemCost * 0.265;
    
    // Calculate subtotal before hidden fees
    const subtotal = totalItemCost + dutyAmount + totalDeliveryFees + totalShippingCost;
    
    // Calculate hidden business costs
    const profitMargin = subtotal * 0.15; // 15% profit margin
    const cardProcessingFee = subtotal * 0.0375; // 3.75% card processing
    const totalHiddenFees = profitMargin + cardProcessingFee;
    
    // Add hidden fees to shipping & handling (customer doesn't see breakdown)
    const totalShippingAndHandling = totalShippingCost + totalHiddenFees;
    
    // Calculate grand total
    const grandTotal = totalItemCost + dutyAmount + totalDeliveryFees + totalShippingAndHandling;
    
    return {
        products: activeProducts,
        deletedCount: scrapedProducts.filter(p => p.deleted).length,
        deliveryFees: deliveryFees || {},
        totals: {
            totalItemCost: Math.round(totalItemCost * 100) / 100,
            dutyAmount: Math.round(dutyAmount * 100) / 100,
            totalDeliveryFees: Math.round(totalDeliveryFees * 100) / 100,
            totalShippingAndHandling: Math.round(totalShippingAndHandling * 100) / 100,
            grandTotal: Math.round(grandTotal * 100) / 100
        },
        originalUrls: document.getElementById('productUrls').value,
        // Internal tracking (not displayed to customer)
        _hiddenFees: {
            profitMargin: Math.round(profitMargin * 100) / 100,
            cardProcessingFee: Math.round(cardProcessingFee * 100) / 100,
            totalHidden: Math.round(totalHiddenFees * 100) / 100
        }
    };
}

// Enhanced calculateAndProceed function with better validation
async function calculateAndProceed() {
    // Check for products that haven't been deleted
    const activeProducts = scrapedProducts.filter(p => !p.deleted);
    
    if (activeProducts.length === 0) {
        alert('No products remaining to calculate. Please add some products first.');
        return;
    }
    
    // Check for unconfirmed prices
    const unconfirmedPrices = [];
    const unconfirmedDeliveryFees = [];
    
    activeProducts.forEach((product, index) => {
        const vendor = product.retailer || 'Unknown';
        const vendorProducts = vendorGroups[vendor] || [];
        const productIndex = vendorProducts.indexOf(product);
        const productId = `${vendor.replace(/\s+/g, '')}-${productIndex}`;
        
        const priceInput = document.getElementById(`price-${productId}`);
        if (priceInput && !priceInput.classList.contains('confirmed')) {
            const price = parseFloat(priceInput.value) || 0;
            if (price > 0) {
                unconfirmedPrices.push(product.name);
            } else {
                alert(`Please enter a price for: ${product.name}`);
                return;
            }
        }
    });
    
    // Check delivery fees
    Object.keys(vendorGroups).forEach(vendor => {
        const input = document.getElementById(`delivery-${vendor}`);
        if (input && parseFloat(input.value) > 0 && !confirmedDeliveryFees.has(vendor)) {
            unconfirmedDeliveryFees.push(vendor);
        }
    });
    
    // Warn about unconfirmed items
    let warningMessage = '';
    if (unconfirmedPrices.length > 0) {
        warningMessage += `Unconfirmed prices for: ${unconfirmedPrices.join(', ')}\n`;
    }
    if (unconfirmedDeliveryFees.length > 0) {
        warningMessage += `Unconfirmed delivery fees for: ${unconfirmedDeliveryFees.join(', ')}\n`;
    }
    
    if (warningMessage) {
        warningMessage += '\nUnconfirmed values may cause delays. Continue anyway?';
        if (!confirm(warningMessage)) {
            return;
        }
    }
    
    // Collect delivery fees
    const deliveryFees = {};
    Object.keys(vendorGroups).forEach(vendor => {
        const input = document.getElementById(`delivery-${vendor}`);
        if (input) {
            deliveryFees[vendor] = parseFloat(input.value) || 0;
        }
    });
    
    // Calculate totals
    const calculation = calculateTotals(deliveryFees);
    finalCalculation = calculation;
    
    console.log('Final calculation:', calculation);
    
    // Display breakdown and go to final page
    displayFinalBreakdown(calculation);
    goToPage(3);
}

// Enhanced error handling for scrapeProducts function
async function scrapeProducts(urls) {
    document.getElementById('loading').classList.add('active');
    document.getElementById('error').classList.remove('active');
    
    try {
        console.log('Starting scrape for URLs:', urls);
        
        const response = await fetch('/api/scrape', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ urls })
        });
        
        console.log('Scrape response status:', response.status);
        
        if (!response.ok) {
            let errorMessage = `HTTP ${response.status}`;
            try {
                const errorData = await response.json();
                errorMessage = errorData.error || errorMessage;
            } catch (e) {
                // If can't parse JSON, use status text
                errorMessage = response.statusText || errorMessage;
            }
            throw new Error(errorMessage);
        }
        
        const data = await response.json();
        console.log('Scrape response data:', data);
        
        if (!data.products || !Array.isArray(data.products)) {
            throw new Error('Invalid response format - no products array');
        }
        
        scrapedProducts = data.products;
        vendorGroups = groupProductsByVendor(scrapedProducts);
        
        displayVendorGroups();
        document.getElementById('loading').classList.remove('active');
        
        // Show summary
        if (data.summary) {
            console.log('Scraping Summary:', data.summary);
        }
        
        // Show success message
        const successMsg = `Successfully loaded ${scrapedProducts.length} products! Please review and confirm all prices before proceeding.`;
        console.log(successMsg);
        
    } catch (error) {
        console.error('Scraping failed:', error);
        document.getElementById('loading').classList.remove('active');
        document.getElementById('error').classList.add('active');
        document.getElementById('error').innerHTML = `
            <strong>Failed to load products:</strong><br>
            ${error.message}<br><br>
            <strong>Possible solutions:</strong><br>
            • Check that all URLs are valid and accessible<br>
            • Try again in a few moments<br>
            • Contact support if the problem persists
        `;
    }
}
